// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/tinygodsdev/tinycooksweb/pkg/storage/entstorage/ent/equipment"
	"github.com/tinygodsdev/tinycooksweb/pkg/storage/entstorage/ent/idea"
	"github.com/tinygodsdev/tinycooksweb/pkg/storage/entstorage/ent/ingredient"
	"github.com/tinygodsdev/tinycooksweb/pkg/storage/entstorage/ent/instruction"
	"github.com/tinygodsdev/tinycooksweb/pkg/storage/entstorage/ent/nutrition"
	"github.com/tinygodsdev/tinycooksweb/pkg/storage/entstorage/ent/predicate"
	"github.com/tinygodsdev/tinycooksweb/pkg/storage/entstorage/ent/product"
	"github.com/tinygodsdev/tinycooksweb/pkg/storage/entstorage/ent/recipe"
	"github.com/tinygodsdev/tinycooksweb/pkg/storage/entstorage/ent/source"
	"github.com/tinygodsdev/tinycooksweb/pkg/storage/entstorage/ent/tag"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeEquipment   = "Equipment"
	TypeIdea        = "Idea"
	TypeIngredient  = "Ingredient"
	TypeInstruction = "Instruction"
	TypeNutrition   = "Nutrition"
	TypeProduct     = "Product"
	TypeRecipe      = "Recipe"
	TypeSource      = "Source"
	TypeTag         = "Tag"
)

// EquipmentMutation represents an operation that mutates the Equipment nodes in the graph.
type EquipmentMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	name           *string
	clearedFields  map[string]struct{}
	recipes        map[uuid.UUID]struct{}
	removedrecipes map[uuid.UUID]struct{}
	clearedrecipes bool
	done           bool
	oldValue       func(context.Context) (*Equipment, error)
	predicates     []predicate.Equipment
}

var _ ent.Mutation = (*EquipmentMutation)(nil)

// equipmentOption allows management of the mutation configuration using functional options.
type equipmentOption func(*EquipmentMutation)

// newEquipmentMutation creates new mutation for the Equipment entity.
func newEquipmentMutation(c config, op Op, opts ...equipmentOption) *EquipmentMutation {
	m := &EquipmentMutation{
		config:        c,
		op:            op,
		typ:           TypeEquipment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEquipmentID sets the ID field of the mutation.
func withEquipmentID(id uuid.UUID) equipmentOption {
	return func(m *EquipmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Equipment
		)
		m.oldValue = func(ctx context.Context) (*Equipment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Equipment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEquipment sets the old Equipment of the mutation.
func withEquipment(node *Equipment) equipmentOption {
	return func(m *EquipmentMutation) {
		m.oldValue = func(context.Context) (*Equipment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EquipmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EquipmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Equipment entities.
func (m *EquipmentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EquipmentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EquipmentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Equipment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *EquipmentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EquipmentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Equipment entity.
// If the Equipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EquipmentMutation) ResetName() {
	m.name = nil
}

// AddRecipeIDs adds the "recipes" edge to the Recipe entity by ids.
func (m *EquipmentMutation) AddRecipeIDs(ids ...uuid.UUID) {
	if m.recipes == nil {
		m.recipes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.recipes[ids[i]] = struct{}{}
	}
}

// ClearRecipes clears the "recipes" edge to the Recipe entity.
func (m *EquipmentMutation) ClearRecipes() {
	m.clearedrecipes = true
}

// RecipesCleared reports if the "recipes" edge to the Recipe entity was cleared.
func (m *EquipmentMutation) RecipesCleared() bool {
	return m.clearedrecipes
}

// RemoveRecipeIDs removes the "recipes" edge to the Recipe entity by IDs.
func (m *EquipmentMutation) RemoveRecipeIDs(ids ...uuid.UUID) {
	if m.removedrecipes == nil {
		m.removedrecipes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.recipes, ids[i])
		m.removedrecipes[ids[i]] = struct{}{}
	}
}

// RemovedRecipes returns the removed IDs of the "recipes" edge to the Recipe entity.
func (m *EquipmentMutation) RemovedRecipesIDs() (ids []uuid.UUID) {
	for id := range m.removedrecipes {
		ids = append(ids, id)
	}
	return
}

// RecipesIDs returns the "recipes" edge IDs in the mutation.
func (m *EquipmentMutation) RecipesIDs() (ids []uuid.UUID) {
	for id := range m.recipes {
		ids = append(ids, id)
	}
	return
}

// ResetRecipes resets all changes to the "recipes" edge.
func (m *EquipmentMutation) ResetRecipes() {
	m.recipes = nil
	m.clearedrecipes = false
	m.removedrecipes = nil
}

// Where appends a list predicates to the EquipmentMutation builder.
func (m *EquipmentMutation) Where(ps ...predicate.Equipment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EquipmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EquipmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Equipment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EquipmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EquipmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Equipment).
func (m *EquipmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EquipmentMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, equipment.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EquipmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case equipment.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EquipmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case equipment.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Equipment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EquipmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case equipment.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Equipment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EquipmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EquipmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EquipmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Equipment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EquipmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EquipmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EquipmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Equipment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EquipmentMutation) ResetField(name string) error {
	switch name {
	case equipment.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Equipment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EquipmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.recipes != nil {
		edges = append(edges, equipment.EdgeRecipes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EquipmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case equipment.EdgeRecipes:
		ids := make([]ent.Value, 0, len(m.recipes))
		for id := range m.recipes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EquipmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedrecipes != nil {
		edges = append(edges, equipment.EdgeRecipes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EquipmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case equipment.EdgeRecipes:
		ids := make([]ent.Value, 0, len(m.removedrecipes))
		for id := range m.removedrecipes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EquipmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrecipes {
		edges = append(edges, equipment.EdgeRecipes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EquipmentMutation) EdgeCleared(name string) bool {
	switch name {
	case equipment.EdgeRecipes:
		return m.clearedrecipes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EquipmentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Equipment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EquipmentMutation) ResetEdge(name string) error {
	switch name {
	case equipment.EdgeRecipes:
		m.ResetRecipes()
		return nil
	}
	return fmt.Errorf("unknown Equipment edge %s", name)
}

// IdeaMutation represents an operation that mutates the Idea nodes in the graph.
type IdeaMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	text          *string
	clearedFields map[string]struct{}
	recipe        *uuid.UUID
	clearedrecipe bool
	done          bool
	oldValue      func(context.Context) (*Idea, error)
	predicates    []predicate.Idea
}

var _ ent.Mutation = (*IdeaMutation)(nil)

// ideaOption allows management of the mutation configuration using functional options.
type ideaOption func(*IdeaMutation)

// newIdeaMutation creates new mutation for the Idea entity.
func newIdeaMutation(c config, op Op, opts ...ideaOption) *IdeaMutation {
	m := &IdeaMutation{
		config:        c,
		op:            op,
		typ:           TypeIdea,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIdeaID sets the ID field of the mutation.
func withIdeaID(id uuid.UUID) ideaOption {
	return func(m *IdeaMutation) {
		var (
			err   error
			once  sync.Once
			value *Idea
		)
		m.oldValue = func(ctx context.Context) (*Idea, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Idea.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIdea sets the old Idea of the mutation.
func withIdea(node *Idea) ideaOption {
	return func(m *IdeaMutation) {
		m.oldValue = func(context.Context) (*Idea, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IdeaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IdeaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Idea entities.
func (m *IdeaMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IdeaMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IdeaMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Idea.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetText sets the "text" field.
func (m *IdeaMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *IdeaMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the Idea entity.
// If the Idea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ResetText resets all changes to the "text" field.
func (m *IdeaMutation) ResetText() {
	m.text = nil
}

// SetRecipeID sets the "recipe" edge to the Recipe entity by id.
func (m *IdeaMutation) SetRecipeID(id uuid.UUID) {
	m.recipe = &id
}

// ClearRecipe clears the "recipe" edge to the Recipe entity.
func (m *IdeaMutation) ClearRecipe() {
	m.clearedrecipe = true
}

// RecipeCleared reports if the "recipe" edge to the Recipe entity was cleared.
func (m *IdeaMutation) RecipeCleared() bool {
	return m.clearedrecipe
}

// RecipeID returns the "recipe" edge ID in the mutation.
func (m *IdeaMutation) RecipeID() (id uuid.UUID, exists bool) {
	if m.recipe != nil {
		return *m.recipe, true
	}
	return
}

// RecipeIDs returns the "recipe" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RecipeID instead. It exists only for internal usage by the builders.
func (m *IdeaMutation) RecipeIDs() (ids []uuid.UUID) {
	if id := m.recipe; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRecipe resets all changes to the "recipe" edge.
func (m *IdeaMutation) ResetRecipe() {
	m.recipe = nil
	m.clearedrecipe = false
}

// Where appends a list predicates to the IdeaMutation builder.
func (m *IdeaMutation) Where(ps ...predicate.Idea) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IdeaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IdeaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Idea, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IdeaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IdeaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Idea).
func (m *IdeaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IdeaMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.text != nil {
		fields = append(fields, idea.FieldText)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IdeaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case idea.FieldText:
		return m.Text()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IdeaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case idea.FieldText:
		return m.OldText(ctx)
	}
	return nil, fmt.Errorf("unknown Idea field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IdeaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case idea.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	}
	return fmt.Errorf("unknown Idea field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IdeaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IdeaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IdeaMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Idea numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IdeaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IdeaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IdeaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Idea nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IdeaMutation) ResetField(name string) error {
	switch name {
	case idea.FieldText:
		m.ResetText()
		return nil
	}
	return fmt.Errorf("unknown Idea field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IdeaMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.recipe != nil {
		edges = append(edges, idea.EdgeRecipe)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IdeaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case idea.EdgeRecipe:
		if id := m.recipe; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IdeaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IdeaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IdeaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrecipe {
		edges = append(edges, idea.EdgeRecipe)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IdeaMutation) EdgeCleared(name string) bool {
	switch name {
	case idea.EdgeRecipe:
		return m.clearedrecipe
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IdeaMutation) ClearEdge(name string) error {
	switch name {
	case idea.EdgeRecipe:
		m.ClearRecipe()
		return nil
	}
	return fmt.Errorf("unknown Idea unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IdeaMutation) ResetEdge(name string) error {
	switch name {
	case idea.EdgeRecipe:
		m.ResetRecipe()
		return nil
	}
	return fmt.Errorf("unknown Idea edge %s", name)
}

// IngredientMutation represents an operation that mutates the Ingredient nodes in the graph.
type IngredientMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	create_time    *time.Time
	update_time    *time.Time
	quantity       *string
	unit           *string
	optional       *bool
	clearedFields  map[string]struct{}
	recipe         *uuid.UUID
	clearedrecipe  bool
	product        *uuid.UUID
	clearedproduct bool
	done           bool
	oldValue       func(context.Context) (*Ingredient, error)
	predicates     []predicate.Ingredient
}

var _ ent.Mutation = (*IngredientMutation)(nil)

// ingredientOption allows management of the mutation configuration using functional options.
type ingredientOption func(*IngredientMutation)

// newIngredientMutation creates new mutation for the Ingredient entity.
func newIngredientMutation(c config, op Op, opts ...ingredientOption) *IngredientMutation {
	m := &IngredientMutation{
		config:        c,
		op:            op,
		typ:           TypeIngredient,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIngredientID sets the ID field of the mutation.
func withIngredientID(id uuid.UUID) ingredientOption {
	return func(m *IngredientMutation) {
		var (
			err   error
			once  sync.Once
			value *Ingredient
		)
		m.oldValue = func(ctx context.Context) (*Ingredient, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ingredient.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIngredient sets the old Ingredient of the mutation.
func withIngredient(node *Ingredient) ingredientOption {
	return func(m *IngredientMutation) {
		m.oldValue = func(context.Context) (*Ingredient, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IngredientMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IngredientMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Ingredient entities.
func (m *IngredientMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IngredientMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IngredientMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Ingredient.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *IngredientMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *IngredientMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Ingredient entity.
// If the Ingredient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IngredientMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *IngredientMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *IngredientMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *IngredientMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Ingredient entity.
// If the Ingredient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IngredientMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *IngredientMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetQuantity sets the "quantity" field.
func (m *IngredientMutation) SetQuantity(s string) {
	m.quantity = &s
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *IngredientMutation) Quantity() (r string, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the Ingredient entity.
// If the Ingredient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IngredientMutation) OldQuantity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// ClearQuantity clears the value of the "quantity" field.
func (m *IngredientMutation) ClearQuantity() {
	m.quantity = nil
	m.clearedFields[ingredient.FieldQuantity] = struct{}{}
}

// QuantityCleared returns if the "quantity" field was cleared in this mutation.
func (m *IngredientMutation) QuantityCleared() bool {
	_, ok := m.clearedFields[ingredient.FieldQuantity]
	return ok
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *IngredientMutation) ResetQuantity() {
	m.quantity = nil
	delete(m.clearedFields, ingredient.FieldQuantity)
}

// SetUnit sets the "unit" field.
func (m *IngredientMutation) SetUnit(s string) {
	m.unit = &s
}

// Unit returns the value of the "unit" field in the mutation.
func (m *IngredientMutation) Unit() (r string, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnit returns the old "unit" field's value of the Ingredient entity.
// If the Ingredient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IngredientMutation) OldUnit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnit: %w", err)
	}
	return oldValue.Unit, nil
}

// ClearUnit clears the value of the "unit" field.
func (m *IngredientMutation) ClearUnit() {
	m.unit = nil
	m.clearedFields[ingredient.FieldUnit] = struct{}{}
}

// UnitCleared returns if the "unit" field was cleared in this mutation.
func (m *IngredientMutation) UnitCleared() bool {
	_, ok := m.clearedFields[ingredient.FieldUnit]
	return ok
}

// ResetUnit resets all changes to the "unit" field.
func (m *IngredientMutation) ResetUnit() {
	m.unit = nil
	delete(m.clearedFields, ingredient.FieldUnit)
}

// SetRecipeID sets the "recipe_id" field.
func (m *IngredientMutation) SetRecipeID(u uuid.UUID) {
	m.recipe = &u
}

// RecipeID returns the value of the "recipe_id" field in the mutation.
func (m *IngredientMutation) RecipeID() (r uuid.UUID, exists bool) {
	v := m.recipe
	if v == nil {
		return
	}
	return *v, true
}

// OldRecipeID returns the old "recipe_id" field's value of the Ingredient entity.
// If the Ingredient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IngredientMutation) OldRecipeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecipeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecipeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecipeID: %w", err)
	}
	return oldValue.RecipeID, nil
}

// ResetRecipeID resets all changes to the "recipe_id" field.
func (m *IngredientMutation) ResetRecipeID() {
	m.recipe = nil
}

// SetProductID sets the "product_id" field.
func (m *IngredientMutation) SetProductID(u uuid.UUID) {
	m.product = &u
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *IngredientMutation) ProductID() (r uuid.UUID, exists bool) {
	v := m.product
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the Ingredient entity.
// If the Ingredient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IngredientMutation) OldProductID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// ResetProductID resets all changes to the "product_id" field.
func (m *IngredientMutation) ResetProductID() {
	m.product = nil
}

// SetOptional sets the "optional" field.
func (m *IngredientMutation) SetOptional(b bool) {
	m.optional = &b
}

// Optional returns the value of the "optional" field in the mutation.
func (m *IngredientMutation) Optional() (r bool, exists bool) {
	v := m.optional
	if v == nil {
		return
	}
	return *v, true
}

// OldOptional returns the old "optional" field's value of the Ingredient entity.
// If the Ingredient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IngredientMutation) OldOptional(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOptional is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOptional requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOptional: %w", err)
	}
	return oldValue.Optional, nil
}

// ResetOptional resets all changes to the "optional" field.
func (m *IngredientMutation) ResetOptional() {
	m.optional = nil
}

// ClearRecipe clears the "recipe" edge to the Recipe entity.
func (m *IngredientMutation) ClearRecipe() {
	m.clearedrecipe = true
	m.clearedFields[ingredient.FieldRecipeID] = struct{}{}
}

// RecipeCleared reports if the "recipe" edge to the Recipe entity was cleared.
func (m *IngredientMutation) RecipeCleared() bool {
	return m.clearedrecipe
}

// RecipeIDs returns the "recipe" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RecipeID instead. It exists only for internal usage by the builders.
func (m *IngredientMutation) RecipeIDs() (ids []uuid.UUID) {
	if id := m.recipe; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRecipe resets all changes to the "recipe" edge.
func (m *IngredientMutation) ResetRecipe() {
	m.recipe = nil
	m.clearedrecipe = false
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *IngredientMutation) ClearProduct() {
	m.clearedproduct = true
	m.clearedFields[ingredient.FieldProductID] = struct{}{}
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *IngredientMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *IngredientMutation) ProductIDs() (ids []uuid.UUID) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *IngredientMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// Where appends a list predicates to the IngredientMutation builder.
func (m *IngredientMutation) Where(ps ...predicate.Ingredient) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IngredientMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IngredientMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Ingredient, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IngredientMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IngredientMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Ingredient).
func (m *IngredientMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IngredientMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, ingredient.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, ingredient.FieldUpdateTime)
	}
	if m.quantity != nil {
		fields = append(fields, ingredient.FieldQuantity)
	}
	if m.unit != nil {
		fields = append(fields, ingredient.FieldUnit)
	}
	if m.recipe != nil {
		fields = append(fields, ingredient.FieldRecipeID)
	}
	if m.product != nil {
		fields = append(fields, ingredient.FieldProductID)
	}
	if m.optional != nil {
		fields = append(fields, ingredient.FieldOptional)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IngredientMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ingredient.FieldCreateTime:
		return m.CreateTime()
	case ingredient.FieldUpdateTime:
		return m.UpdateTime()
	case ingredient.FieldQuantity:
		return m.Quantity()
	case ingredient.FieldUnit:
		return m.Unit()
	case ingredient.FieldRecipeID:
		return m.RecipeID()
	case ingredient.FieldProductID:
		return m.ProductID()
	case ingredient.FieldOptional:
		return m.Optional()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IngredientMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ingredient.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case ingredient.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case ingredient.FieldQuantity:
		return m.OldQuantity(ctx)
	case ingredient.FieldUnit:
		return m.OldUnit(ctx)
	case ingredient.FieldRecipeID:
		return m.OldRecipeID(ctx)
	case ingredient.FieldProductID:
		return m.OldProductID(ctx)
	case ingredient.FieldOptional:
		return m.OldOptional(ctx)
	}
	return nil, fmt.Errorf("unknown Ingredient field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IngredientMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ingredient.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case ingredient.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case ingredient.FieldQuantity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case ingredient.FieldUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnit(v)
		return nil
	case ingredient.FieldRecipeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecipeID(v)
		return nil
	case ingredient.FieldProductID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case ingredient.FieldOptional:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOptional(v)
		return nil
	}
	return fmt.Errorf("unknown Ingredient field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IngredientMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IngredientMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IngredientMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Ingredient numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IngredientMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ingredient.FieldQuantity) {
		fields = append(fields, ingredient.FieldQuantity)
	}
	if m.FieldCleared(ingredient.FieldUnit) {
		fields = append(fields, ingredient.FieldUnit)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IngredientMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IngredientMutation) ClearField(name string) error {
	switch name {
	case ingredient.FieldQuantity:
		m.ClearQuantity()
		return nil
	case ingredient.FieldUnit:
		m.ClearUnit()
		return nil
	}
	return fmt.Errorf("unknown Ingredient nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IngredientMutation) ResetField(name string) error {
	switch name {
	case ingredient.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case ingredient.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case ingredient.FieldQuantity:
		m.ResetQuantity()
		return nil
	case ingredient.FieldUnit:
		m.ResetUnit()
		return nil
	case ingredient.FieldRecipeID:
		m.ResetRecipeID()
		return nil
	case ingredient.FieldProductID:
		m.ResetProductID()
		return nil
	case ingredient.FieldOptional:
		m.ResetOptional()
		return nil
	}
	return fmt.Errorf("unknown Ingredient field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IngredientMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.recipe != nil {
		edges = append(edges, ingredient.EdgeRecipe)
	}
	if m.product != nil {
		edges = append(edges, ingredient.EdgeProduct)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IngredientMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ingredient.EdgeRecipe:
		if id := m.recipe; id != nil {
			return []ent.Value{*id}
		}
	case ingredient.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IngredientMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IngredientMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IngredientMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrecipe {
		edges = append(edges, ingredient.EdgeRecipe)
	}
	if m.clearedproduct {
		edges = append(edges, ingredient.EdgeProduct)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IngredientMutation) EdgeCleared(name string) bool {
	switch name {
	case ingredient.EdgeRecipe:
		return m.clearedrecipe
	case ingredient.EdgeProduct:
		return m.clearedproduct
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IngredientMutation) ClearEdge(name string) error {
	switch name {
	case ingredient.EdgeRecipe:
		m.ClearRecipe()
		return nil
	case ingredient.EdgeProduct:
		m.ClearProduct()
		return nil
	}
	return fmt.Errorf("unknown Ingredient unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IngredientMutation) ResetEdge(name string) error {
	switch name {
	case ingredient.EdgeRecipe:
		m.ResetRecipe()
		return nil
	case ingredient.EdgeProduct:
		m.ResetProduct()
		return nil
	}
	return fmt.Errorf("unknown Ingredient edge %s", name)
}

// InstructionMutation represents an operation that mutates the Instruction nodes in the graph.
type InstructionMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	text          *string
	_order        *int
	add_order     *int
	clearedFields map[string]struct{}
	recipe        *uuid.UUID
	clearedrecipe bool
	done          bool
	oldValue      func(context.Context) (*Instruction, error)
	predicates    []predicate.Instruction
}

var _ ent.Mutation = (*InstructionMutation)(nil)

// instructionOption allows management of the mutation configuration using functional options.
type instructionOption func(*InstructionMutation)

// newInstructionMutation creates new mutation for the Instruction entity.
func newInstructionMutation(c config, op Op, opts ...instructionOption) *InstructionMutation {
	m := &InstructionMutation{
		config:        c,
		op:            op,
		typ:           TypeInstruction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInstructionID sets the ID field of the mutation.
func withInstructionID(id uuid.UUID) instructionOption {
	return func(m *InstructionMutation) {
		var (
			err   error
			once  sync.Once
			value *Instruction
		)
		m.oldValue = func(ctx context.Context) (*Instruction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Instruction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInstruction sets the old Instruction of the mutation.
func withInstruction(node *Instruction) instructionOption {
	return func(m *InstructionMutation) {
		m.oldValue = func(context.Context) (*Instruction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InstructionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InstructionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Instruction entities.
func (m *InstructionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InstructionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InstructionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Instruction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetText sets the "text" field.
func (m *InstructionMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *InstructionMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the Instruction entity.
// If the Instruction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstructionMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ResetText resets all changes to the "text" field.
func (m *InstructionMutation) ResetText() {
	m.text = nil
}

// SetOrder sets the "order" field.
func (m *InstructionMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *InstructionMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the Instruction entity.
// If the Instruction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstructionMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *InstructionMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *InstructionMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *InstructionMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// SetRecipeID sets the "recipe" edge to the Recipe entity by id.
func (m *InstructionMutation) SetRecipeID(id uuid.UUID) {
	m.recipe = &id
}

// ClearRecipe clears the "recipe" edge to the Recipe entity.
func (m *InstructionMutation) ClearRecipe() {
	m.clearedrecipe = true
}

// RecipeCleared reports if the "recipe" edge to the Recipe entity was cleared.
func (m *InstructionMutation) RecipeCleared() bool {
	return m.clearedrecipe
}

// RecipeID returns the "recipe" edge ID in the mutation.
func (m *InstructionMutation) RecipeID() (id uuid.UUID, exists bool) {
	if m.recipe != nil {
		return *m.recipe, true
	}
	return
}

// RecipeIDs returns the "recipe" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RecipeID instead. It exists only for internal usage by the builders.
func (m *InstructionMutation) RecipeIDs() (ids []uuid.UUID) {
	if id := m.recipe; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRecipe resets all changes to the "recipe" edge.
func (m *InstructionMutation) ResetRecipe() {
	m.recipe = nil
	m.clearedrecipe = false
}

// Where appends a list predicates to the InstructionMutation builder.
func (m *InstructionMutation) Where(ps ...predicate.Instruction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InstructionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InstructionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Instruction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InstructionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InstructionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Instruction).
func (m *InstructionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InstructionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.text != nil {
		fields = append(fields, instruction.FieldText)
	}
	if m._order != nil {
		fields = append(fields, instruction.FieldOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InstructionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case instruction.FieldText:
		return m.Text()
	case instruction.FieldOrder:
		return m.Order()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InstructionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case instruction.FieldText:
		return m.OldText(ctx)
	case instruction.FieldOrder:
		return m.OldOrder(ctx)
	}
	return nil, fmt.Errorf("unknown Instruction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InstructionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case instruction.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	case instruction.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Instruction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InstructionMutation) AddedFields() []string {
	var fields []string
	if m.add_order != nil {
		fields = append(fields, instruction.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InstructionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case instruction.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InstructionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case instruction.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Instruction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InstructionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InstructionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InstructionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Instruction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InstructionMutation) ResetField(name string) error {
	switch name {
	case instruction.FieldText:
		m.ResetText()
		return nil
	case instruction.FieldOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown Instruction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InstructionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.recipe != nil {
		edges = append(edges, instruction.EdgeRecipe)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InstructionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case instruction.EdgeRecipe:
		if id := m.recipe; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InstructionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InstructionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InstructionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrecipe {
		edges = append(edges, instruction.EdgeRecipe)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InstructionMutation) EdgeCleared(name string) bool {
	switch name {
	case instruction.EdgeRecipe:
		return m.clearedrecipe
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InstructionMutation) ClearEdge(name string) error {
	switch name {
	case instruction.EdgeRecipe:
		m.ClearRecipe()
		return nil
	}
	return fmt.Errorf("unknown Instruction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InstructionMutation) ResetEdge(name string) error {
	switch name {
	case instruction.EdgeRecipe:
		m.ResetRecipe()
		return nil
	}
	return fmt.Errorf("unknown Instruction edge %s", name)
}

// NutritionMutation represents an operation that mutates the Nutrition nodes in the graph.
type NutritionMutation struct {
	config
	op             Op
	typ            string
	id             *int
	calories       *int
	addcalories    *int
	fat            *int
	addfat         *int
	carbs          *int
	addcarbs       *int
	protein        *int
	addprotein     *int
	precision      *string
	benefits       *[]string
	appendbenefits []string
	clearedFields  map[string]struct{}
	recipe         *uuid.UUID
	clearedrecipe  bool
	done           bool
	oldValue       func(context.Context) (*Nutrition, error)
	predicates     []predicate.Nutrition
}

var _ ent.Mutation = (*NutritionMutation)(nil)

// nutritionOption allows management of the mutation configuration using functional options.
type nutritionOption func(*NutritionMutation)

// newNutritionMutation creates new mutation for the Nutrition entity.
func newNutritionMutation(c config, op Op, opts ...nutritionOption) *NutritionMutation {
	m := &NutritionMutation{
		config:        c,
		op:            op,
		typ:           TypeNutrition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNutritionID sets the ID field of the mutation.
func withNutritionID(id int) nutritionOption {
	return func(m *NutritionMutation) {
		var (
			err   error
			once  sync.Once
			value *Nutrition
		)
		m.oldValue = func(ctx context.Context) (*Nutrition, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Nutrition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNutrition sets the old Nutrition of the mutation.
func withNutrition(node *Nutrition) nutritionOption {
	return func(m *NutritionMutation) {
		m.oldValue = func(context.Context) (*Nutrition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NutritionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NutritionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NutritionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NutritionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Nutrition.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCalories sets the "calories" field.
func (m *NutritionMutation) SetCalories(i int) {
	m.calories = &i
	m.addcalories = nil
}

// Calories returns the value of the "calories" field in the mutation.
func (m *NutritionMutation) Calories() (r int, exists bool) {
	v := m.calories
	if v == nil {
		return
	}
	return *v, true
}

// OldCalories returns the old "calories" field's value of the Nutrition entity.
// If the Nutrition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NutritionMutation) OldCalories(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCalories is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCalories requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalories: %w", err)
	}
	return oldValue.Calories, nil
}

// AddCalories adds i to the "calories" field.
func (m *NutritionMutation) AddCalories(i int) {
	if m.addcalories != nil {
		*m.addcalories += i
	} else {
		m.addcalories = &i
	}
}

// AddedCalories returns the value that was added to the "calories" field in this mutation.
func (m *NutritionMutation) AddedCalories() (r int, exists bool) {
	v := m.addcalories
	if v == nil {
		return
	}
	return *v, true
}

// ClearCalories clears the value of the "calories" field.
func (m *NutritionMutation) ClearCalories() {
	m.calories = nil
	m.addcalories = nil
	m.clearedFields[nutrition.FieldCalories] = struct{}{}
}

// CaloriesCleared returns if the "calories" field was cleared in this mutation.
func (m *NutritionMutation) CaloriesCleared() bool {
	_, ok := m.clearedFields[nutrition.FieldCalories]
	return ok
}

// ResetCalories resets all changes to the "calories" field.
func (m *NutritionMutation) ResetCalories() {
	m.calories = nil
	m.addcalories = nil
	delete(m.clearedFields, nutrition.FieldCalories)
}

// SetFat sets the "fat" field.
func (m *NutritionMutation) SetFat(i int) {
	m.fat = &i
	m.addfat = nil
}

// Fat returns the value of the "fat" field in the mutation.
func (m *NutritionMutation) Fat() (r int, exists bool) {
	v := m.fat
	if v == nil {
		return
	}
	return *v, true
}

// OldFat returns the old "fat" field's value of the Nutrition entity.
// If the Nutrition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NutritionMutation) OldFat(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFat: %w", err)
	}
	return oldValue.Fat, nil
}

// AddFat adds i to the "fat" field.
func (m *NutritionMutation) AddFat(i int) {
	if m.addfat != nil {
		*m.addfat += i
	} else {
		m.addfat = &i
	}
}

// AddedFat returns the value that was added to the "fat" field in this mutation.
func (m *NutritionMutation) AddedFat() (r int, exists bool) {
	v := m.addfat
	if v == nil {
		return
	}
	return *v, true
}

// ClearFat clears the value of the "fat" field.
func (m *NutritionMutation) ClearFat() {
	m.fat = nil
	m.addfat = nil
	m.clearedFields[nutrition.FieldFat] = struct{}{}
}

// FatCleared returns if the "fat" field was cleared in this mutation.
func (m *NutritionMutation) FatCleared() bool {
	_, ok := m.clearedFields[nutrition.FieldFat]
	return ok
}

// ResetFat resets all changes to the "fat" field.
func (m *NutritionMutation) ResetFat() {
	m.fat = nil
	m.addfat = nil
	delete(m.clearedFields, nutrition.FieldFat)
}

// SetCarbs sets the "carbs" field.
func (m *NutritionMutation) SetCarbs(i int) {
	m.carbs = &i
	m.addcarbs = nil
}

// Carbs returns the value of the "carbs" field in the mutation.
func (m *NutritionMutation) Carbs() (r int, exists bool) {
	v := m.carbs
	if v == nil {
		return
	}
	return *v, true
}

// OldCarbs returns the old "carbs" field's value of the Nutrition entity.
// If the Nutrition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NutritionMutation) OldCarbs(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarbs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarbs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarbs: %w", err)
	}
	return oldValue.Carbs, nil
}

// AddCarbs adds i to the "carbs" field.
func (m *NutritionMutation) AddCarbs(i int) {
	if m.addcarbs != nil {
		*m.addcarbs += i
	} else {
		m.addcarbs = &i
	}
}

// AddedCarbs returns the value that was added to the "carbs" field in this mutation.
func (m *NutritionMutation) AddedCarbs() (r int, exists bool) {
	v := m.addcarbs
	if v == nil {
		return
	}
	return *v, true
}

// ClearCarbs clears the value of the "carbs" field.
func (m *NutritionMutation) ClearCarbs() {
	m.carbs = nil
	m.addcarbs = nil
	m.clearedFields[nutrition.FieldCarbs] = struct{}{}
}

// CarbsCleared returns if the "carbs" field was cleared in this mutation.
func (m *NutritionMutation) CarbsCleared() bool {
	_, ok := m.clearedFields[nutrition.FieldCarbs]
	return ok
}

// ResetCarbs resets all changes to the "carbs" field.
func (m *NutritionMutation) ResetCarbs() {
	m.carbs = nil
	m.addcarbs = nil
	delete(m.clearedFields, nutrition.FieldCarbs)
}

// SetProtein sets the "protein" field.
func (m *NutritionMutation) SetProtein(i int) {
	m.protein = &i
	m.addprotein = nil
}

// Protein returns the value of the "protein" field in the mutation.
func (m *NutritionMutation) Protein() (r int, exists bool) {
	v := m.protein
	if v == nil {
		return
	}
	return *v, true
}

// OldProtein returns the old "protein" field's value of the Nutrition entity.
// If the Nutrition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NutritionMutation) OldProtein(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProtein is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProtein requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProtein: %w", err)
	}
	return oldValue.Protein, nil
}

// AddProtein adds i to the "protein" field.
func (m *NutritionMutation) AddProtein(i int) {
	if m.addprotein != nil {
		*m.addprotein += i
	} else {
		m.addprotein = &i
	}
}

// AddedProtein returns the value that was added to the "protein" field in this mutation.
func (m *NutritionMutation) AddedProtein() (r int, exists bool) {
	v := m.addprotein
	if v == nil {
		return
	}
	return *v, true
}

// ClearProtein clears the value of the "protein" field.
func (m *NutritionMutation) ClearProtein() {
	m.protein = nil
	m.addprotein = nil
	m.clearedFields[nutrition.FieldProtein] = struct{}{}
}

// ProteinCleared returns if the "protein" field was cleared in this mutation.
func (m *NutritionMutation) ProteinCleared() bool {
	_, ok := m.clearedFields[nutrition.FieldProtein]
	return ok
}

// ResetProtein resets all changes to the "protein" field.
func (m *NutritionMutation) ResetProtein() {
	m.protein = nil
	m.addprotein = nil
	delete(m.clearedFields, nutrition.FieldProtein)
}

// SetPrecision sets the "precision" field.
func (m *NutritionMutation) SetPrecision(s string) {
	m.precision = &s
}

// Precision returns the value of the "precision" field in the mutation.
func (m *NutritionMutation) Precision() (r string, exists bool) {
	v := m.precision
	if v == nil {
		return
	}
	return *v, true
}

// OldPrecision returns the old "precision" field's value of the Nutrition entity.
// If the Nutrition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NutritionMutation) OldPrecision(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrecision is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrecision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrecision: %w", err)
	}
	return oldValue.Precision, nil
}

// ClearPrecision clears the value of the "precision" field.
func (m *NutritionMutation) ClearPrecision() {
	m.precision = nil
	m.clearedFields[nutrition.FieldPrecision] = struct{}{}
}

// PrecisionCleared returns if the "precision" field was cleared in this mutation.
func (m *NutritionMutation) PrecisionCleared() bool {
	_, ok := m.clearedFields[nutrition.FieldPrecision]
	return ok
}

// ResetPrecision resets all changes to the "precision" field.
func (m *NutritionMutation) ResetPrecision() {
	m.precision = nil
	delete(m.clearedFields, nutrition.FieldPrecision)
}

// SetBenefits sets the "benefits" field.
func (m *NutritionMutation) SetBenefits(s []string) {
	m.benefits = &s
	m.appendbenefits = nil
}

// Benefits returns the value of the "benefits" field in the mutation.
func (m *NutritionMutation) Benefits() (r []string, exists bool) {
	v := m.benefits
	if v == nil {
		return
	}
	return *v, true
}

// OldBenefits returns the old "benefits" field's value of the Nutrition entity.
// If the Nutrition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NutritionMutation) OldBenefits(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBenefits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBenefits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBenefits: %w", err)
	}
	return oldValue.Benefits, nil
}

// AppendBenefits adds s to the "benefits" field.
func (m *NutritionMutation) AppendBenefits(s []string) {
	m.appendbenefits = append(m.appendbenefits, s...)
}

// AppendedBenefits returns the list of values that were appended to the "benefits" field in this mutation.
func (m *NutritionMutation) AppendedBenefits() ([]string, bool) {
	if len(m.appendbenefits) == 0 {
		return nil, false
	}
	return m.appendbenefits, true
}

// ClearBenefits clears the value of the "benefits" field.
func (m *NutritionMutation) ClearBenefits() {
	m.benefits = nil
	m.appendbenefits = nil
	m.clearedFields[nutrition.FieldBenefits] = struct{}{}
}

// BenefitsCleared returns if the "benefits" field was cleared in this mutation.
func (m *NutritionMutation) BenefitsCleared() bool {
	_, ok := m.clearedFields[nutrition.FieldBenefits]
	return ok
}

// ResetBenefits resets all changes to the "benefits" field.
func (m *NutritionMutation) ResetBenefits() {
	m.benefits = nil
	m.appendbenefits = nil
	delete(m.clearedFields, nutrition.FieldBenefits)
}

// SetRecipeID sets the "recipe" edge to the Recipe entity by id.
func (m *NutritionMutation) SetRecipeID(id uuid.UUID) {
	m.recipe = &id
}

// ClearRecipe clears the "recipe" edge to the Recipe entity.
func (m *NutritionMutation) ClearRecipe() {
	m.clearedrecipe = true
}

// RecipeCleared reports if the "recipe" edge to the Recipe entity was cleared.
func (m *NutritionMutation) RecipeCleared() bool {
	return m.clearedrecipe
}

// RecipeID returns the "recipe" edge ID in the mutation.
func (m *NutritionMutation) RecipeID() (id uuid.UUID, exists bool) {
	if m.recipe != nil {
		return *m.recipe, true
	}
	return
}

// RecipeIDs returns the "recipe" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RecipeID instead. It exists only for internal usage by the builders.
func (m *NutritionMutation) RecipeIDs() (ids []uuid.UUID) {
	if id := m.recipe; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRecipe resets all changes to the "recipe" edge.
func (m *NutritionMutation) ResetRecipe() {
	m.recipe = nil
	m.clearedrecipe = false
}

// Where appends a list predicates to the NutritionMutation builder.
func (m *NutritionMutation) Where(ps ...predicate.Nutrition) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NutritionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NutritionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Nutrition, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NutritionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NutritionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Nutrition).
func (m *NutritionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NutritionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.calories != nil {
		fields = append(fields, nutrition.FieldCalories)
	}
	if m.fat != nil {
		fields = append(fields, nutrition.FieldFat)
	}
	if m.carbs != nil {
		fields = append(fields, nutrition.FieldCarbs)
	}
	if m.protein != nil {
		fields = append(fields, nutrition.FieldProtein)
	}
	if m.precision != nil {
		fields = append(fields, nutrition.FieldPrecision)
	}
	if m.benefits != nil {
		fields = append(fields, nutrition.FieldBenefits)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NutritionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case nutrition.FieldCalories:
		return m.Calories()
	case nutrition.FieldFat:
		return m.Fat()
	case nutrition.FieldCarbs:
		return m.Carbs()
	case nutrition.FieldProtein:
		return m.Protein()
	case nutrition.FieldPrecision:
		return m.Precision()
	case nutrition.FieldBenefits:
		return m.Benefits()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NutritionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case nutrition.FieldCalories:
		return m.OldCalories(ctx)
	case nutrition.FieldFat:
		return m.OldFat(ctx)
	case nutrition.FieldCarbs:
		return m.OldCarbs(ctx)
	case nutrition.FieldProtein:
		return m.OldProtein(ctx)
	case nutrition.FieldPrecision:
		return m.OldPrecision(ctx)
	case nutrition.FieldBenefits:
		return m.OldBenefits(ctx)
	}
	return nil, fmt.Errorf("unknown Nutrition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NutritionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case nutrition.FieldCalories:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalories(v)
		return nil
	case nutrition.FieldFat:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFat(v)
		return nil
	case nutrition.FieldCarbs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarbs(v)
		return nil
	case nutrition.FieldProtein:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProtein(v)
		return nil
	case nutrition.FieldPrecision:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrecision(v)
		return nil
	case nutrition.FieldBenefits:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBenefits(v)
		return nil
	}
	return fmt.Errorf("unknown Nutrition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NutritionMutation) AddedFields() []string {
	var fields []string
	if m.addcalories != nil {
		fields = append(fields, nutrition.FieldCalories)
	}
	if m.addfat != nil {
		fields = append(fields, nutrition.FieldFat)
	}
	if m.addcarbs != nil {
		fields = append(fields, nutrition.FieldCarbs)
	}
	if m.addprotein != nil {
		fields = append(fields, nutrition.FieldProtein)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NutritionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case nutrition.FieldCalories:
		return m.AddedCalories()
	case nutrition.FieldFat:
		return m.AddedFat()
	case nutrition.FieldCarbs:
		return m.AddedCarbs()
	case nutrition.FieldProtein:
		return m.AddedProtein()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NutritionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case nutrition.FieldCalories:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCalories(v)
		return nil
	case nutrition.FieldFat:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFat(v)
		return nil
	case nutrition.FieldCarbs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarbs(v)
		return nil
	case nutrition.FieldProtein:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProtein(v)
		return nil
	}
	return fmt.Errorf("unknown Nutrition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NutritionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(nutrition.FieldCalories) {
		fields = append(fields, nutrition.FieldCalories)
	}
	if m.FieldCleared(nutrition.FieldFat) {
		fields = append(fields, nutrition.FieldFat)
	}
	if m.FieldCleared(nutrition.FieldCarbs) {
		fields = append(fields, nutrition.FieldCarbs)
	}
	if m.FieldCleared(nutrition.FieldProtein) {
		fields = append(fields, nutrition.FieldProtein)
	}
	if m.FieldCleared(nutrition.FieldPrecision) {
		fields = append(fields, nutrition.FieldPrecision)
	}
	if m.FieldCleared(nutrition.FieldBenefits) {
		fields = append(fields, nutrition.FieldBenefits)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NutritionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NutritionMutation) ClearField(name string) error {
	switch name {
	case nutrition.FieldCalories:
		m.ClearCalories()
		return nil
	case nutrition.FieldFat:
		m.ClearFat()
		return nil
	case nutrition.FieldCarbs:
		m.ClearCarbs()
		return nil
	case nutrition.FieldProtein:
		m.ClearProtein()
		return nil
	case nutrition.FieldPrecision:
		m.ClearPrecision()
		return nil
	case nutrition.FieldBenefits:
		m.ClearBenefits()
		return nil
	}
	return fmt.Errorf("unknown Nutrition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NutritionMutation) ResetField(name string) error {
	switch name {
	case nutrition.FieldCalories:
		m.ResetCalories()
		return nil
	case nutrition.FieldFat:
		m.ResetFat()
		return nil
	case nutrition.FieldCarbs:
		m.ResetCarbs()
		return nil
	case nutrition.FieldProtein:
		m.ResetProtein()
		return nil
	case nutrition.FieldPrecision:
		m.ResetPrecision()
		return nil
	case nutrition.FieldBenefits:
		m.ResetBenefits()
		return nil
	}
	return fmt.Errorf("unknown Nutrition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NutritionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.recipe != nil {
		edges = append(edges, nutrition.EdgeRecipe)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NutritionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case nutrition.EdgeRecipe:
		if id := m.recipe; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NutritionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NutritionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NutritionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrecipe {
		edges = append(edges, nutrition.EdgeRecipe)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NutritionMutation) EdgeCleared(name string) bool {
	switch name {
	case nutrition.EdgeRecipe:
		return m.clearedrecipe
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NutritionMutation) ClearEdge(name string) error {
	switch name {
	case nutrition.EdgeRecipe:
		m.ClearRecipe()
		return nil
	}
	return fmt.Errorf("unknown Nutrition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NutritionMutation) ResetEdge(name string) error {
	switch name {
	case nutrition.EdgeRecipe:
		m.ResetRecipe()
		return nil
	}
	return fmt.Errorf("unknown Nutrition edge %s", name)
}

// ProductMutation represents an operation that mutates the Product nodes in the graph.
type ProductMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uuid.UUID
	create_time                *time.Time
	update_time                *time.Time
	locale                     *product.Locale
	name                       *string
	clearedFields              map[string]struct{}
	required_in_recipes        map[uuid.UUID]struct{}
	removedrequired_in_recipes map[uuid.UUID]struct{}
	clearedrequired_in_recipes bool
	ingredients                map[uuid.UUID]struct{}
	removedingredients         map[uuid.UUID]struct{}
	clearedingredients         bool
	done                       bool
	oldValue                   func(context.Context) (*Product, error)
	predicates                 []predicate.Product
}

var _ ent.Mutation = (*ProductMutation)(nil)

// productOption allows management of the mutation configuration using functional options.
type productOption func(*ProductMutation)

// newProductMutation creates new mutation for the Product entity.
func newProductMutation(c config, op Op, opts ...productOption) *ProductMutation {
	m := &ProductMutation{
		config:        c,
		op:            op,
		typ:           TypeProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductID sets the ID field of the mutation.
func withProductID(id uuid.UUID) productOption {
	return func(m *ProductMutation) {
		var (
			err   error
			once  sync.Once
			value *Product
		)
		m.oldValue = func(ctx context.Context) (*Product, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Product.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProduct sets the old Product of the mutation.
func withProduct(node *Product) productOption {
	return func(m *ProductMutation) {
		m.oldValue = func(context.Context) (*Product, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Product entities.
func (m *ProductMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Product.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *ProductMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ProductMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ProductMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ProductMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ProductMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ProductMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetLocale sets the "locale" field.
func (m *ProductMutation) SetLocale(pr product.Locale) {
	m.locale = &pr
}

// Locale returns the value of the "locale" field in the mutation.
func (m *ProductMutation) Locale() (r product.Locale, exists bool) {
	v := m.locale
	if v == nil {
		return
	}
	return *v, true
}

// OldLocale returns the old "locale" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldLocale(ctx context.Context) (v product.Locale, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocale is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocale: %w", err)
	}
	return oldValue.Locale, nil
}

// ResetLocale resets all changes to the "locale" field.
func (m *ProductMutation) ResetLocale() {
	m.locale = nil
}

// SetName sets the "name" field.
func (m *ProductMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProductMutation) ResetName() {
	m.name = nil
}

// AddRequiredInRecipeIDs adds the "required_in_recipes" edge to the Recipe entity by ids.
func (m *ProductMutation) AddRequiredInRecipeIDs(ids ...uuid.UUID) {
	if m.required_in_recipes == nil {
		m.required_in_recipes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.required_in_recipes[ids[i]] = struct{}{}
	}
}

// ClearRequiredInRecipes clears the "required_in_recipes" edge to the Recipe entity.
func (m *ProductMutation) ClearRequiredInRecipes() {
	m.clearedrequired_in_recipes = true
}

// RequiredInRecipesCleared reports if the "required_in_recipes" edge to the Recipe entity was cleared.
func (m *ProductMutation) RequiredInRecipesCleared() bool {
	return m.clearedrequired_in_recipes
}

// RemoveRequiredInRecipeIDs removes the "required_in_recipes" edge to the Recipe entity by IDs.
func (m *ProductMutation) RemoveRequiredInRecipeIDs(ids ...uuid.UUID) {
	if m.removedrequired_in_recipes == nil {
		m.removedrequired_in_recipes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.required_in_recipes, ids[i])
		m.removedrequired_in_recipes[ids[i]] = struct{}{}
	}
}

// RemovedRequiredInRecipes returns the removed IDs of the "required_in_recipes" edge to the Recipe entity.
func (m *ProductMutation) RemovedRequiredInRecipesIDs() (ids []uuid.UUID) {
	for id := range m.removedrequired_in_recipes {
		ids = append(ids, id)
	}
	return
}

// RequiredInRecipesIDs returns the "required_in_recipes" edge IDs in the mutation.
func (m *ProductMutation) RequiredInRecipesIDs() (ids []uuid.UUID) {
	for id := range m.required_in_recipes {
		ids = append(ids, id)
	}
	return
}

// ResetRequiredInRecipes resets all changes to the "required_in_recipes" edge.
func (m *ProductMutation) ResetRequiredInRecipes() {
	m.required_in_recipes = nil
	m.clearedrequired_in_recipes = false
	m.removedrequired_in_recipes = nil
}

// AddIngredientIDs adds the "ingredients" edge to the Ingredient entity by ids.
func (m *ProductMutation) AddIngredientIDs(ids ...uuid.UUID) {
	if m.ingredients == nil {
		m.ingredients = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.ingredients[ids[i]] = struct{}{}
	}
}

// ClearIngredients clears the "ingredients" edge to the Ingredient entity.
func (m *ProductMutation) ClearIngredients() {
	m.clearedingredients = true
}

// IngredientsCleared reports if the "ingredients" edge to the Ingredient entity was cleared.
func (m *ProductMutation) IngredientsCleared() bool {
	return m.clearedingredients
}

// RemoveIngredientIDs removes the "ingredients" edge to the Ingredient entity by IDs.
func (m *ProductMutation) RemoveIngredientIDs(ids ...uuid.UUID) {
	if m.removedingredients == nil {
		m.removedingredients = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.ingredients, ids[i])
		m.removedingredients[ids[i]] = struct{}{}
	}
}

// RemovedIngredients returns the removed IDs of the "ingredients" edge to the Ingredient entity.
func (m *ProductMutation) RemovedIngredientsIDs() (ids []uuid.UUID) {
	for id := range m.removedingredients {
		ids = append(ids, id)
	}
	return
}

// IngredientsIDs returns the "ingredients" edge IDs in the mutation.
func (m *ProductMutation) IngredientsIDs() (ids []uuid.UUID) {
	for id := range m.ingredients {
		ids = append(ids, id)
	}
	return
}

// ResetIngredients resets all changes to the "ingredients" edge.
func (m *ProductMutation) ResetIngredients() {
	m.ingredients = nil
	m.clearedingredients = false
	m.removedingredients = nil
}

// Where appends a list predicates to the ProductMutation builder.
func (m *ProductMutation) Where(ps ...predicate.Product) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Product, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Product).
func (m *ProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, product.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, product.FieldUpdateTime)
	}
	if m.locale != nil {
		fields = append(fields, product.FieldLocale)
	}
	if m.name != nil {
		fields = append(fields, product.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case product.FieldCreateTime:
		return m.CreateTime()
	case product.FieldUpdateTime:
		return m.UpdateTime()
	case product.FieldLocale:
		return m.Locale()
	case product.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case product.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case product.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case product.FieldLocale:
		return m.OldLocale(ctx)
	case product.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Product field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case product.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case product.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case product.FieldLocale:
		v, ok := value.(product.Locale)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocale(v)
		return nil
	case product.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Product numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Product nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductMutation) ResetField(name string) error {
	switch name {
	case product.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case product.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case product.FieldLocale:
		m.ResetLocale()
		return nil
	case product.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.required_in_recipes != nil {
		edges = append(edges, product.EdgeRequiredInRecipes)
	}
	if m.ingredients != nil {
		edges = append(edges, product.EdgeIngredients)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeRequiredInRecipes:
		ids := make([]ent.Value, 0, len(m.required_in_recipes))
		for id := range m.required_in_recipes {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeIngredients:
		ids := make([]ent.Value, 0, len(m.ingredients))
		for id := range m.ingredients {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedrequired_in_recipes != nil {
		edges = append(edges, product.EdgeRequiredInRecipes)
	}
	if m.removedingredients != nil {
		edges = append(edges, product.EdgeIngredients)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeRequiredInRecipes:
		ids := make([]ent.Value, 0, len(m.removedrequired_in_recipes))
		for id := range m.removedrequired_in_recipes {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeIngredients:
		ids := make([]ent.Value, 0, len(m.removedingredients))
		for id := range m.removedingredients {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrequired_in_recipes {
		edges = append(edges, product.EdgeRequiredInRecipes)
	}
	if m.clearedingredients {
		edges = append(edges, product.EdgeIngredients)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductMutation) EdgeCleared(name string) bool {
	switch name {
	case product.EdgeRequiredInRecipes:
		return m.clearedrequired_in_recipes
	case product.EdgeIngredients:
		return m.clearedingredients
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Product unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductMutation) ResetEdge(name string) error {
	switch name {
	case product.EdgeRequiredInRecipes:
		m.ResetRequiredInRecipes()
		return nil
	case product.EdgeIngredients:
		m.ResetIngredients()
		return nil
	}
	return fmt.Errorf("unknown Product edge %s", name)
}

// RecipeMutation represents an operation that mutates the Recipe nodes in the graph.
type RecipeMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	create_time              *time.Time
	update_time              *time.Time
	locale                   *recipe.Locale
	name                     *string
	slug                     *string
	description              *string
	text                     *string
	servings                 *int
	addservings              *int
	time                     *time.Duration
	addtime                  *time.Duration
	clearedFields            map[string]struct{}
	required_products        map[uuid.UUID]struct{}
	removedrequired_products map[uuid.UUID]struct{}
	clearedrequired_products bool
	instructions             map[uuid.UUID]struct{}
	removedinstructions      map[uuid.UUID]struct{}
	clearedinstructions      bool
	tags                     map[uuid.UUID]struct{}
	removedtags              map[uuid.UUID]struct{}
	clearedtags              bool
	equipment                map[uuid.UUID]struct{}
	removedequipment         map[uuid.UUID]struct{}
	clearedequipment         bool
	ideas                    map[uuid.UUID]struct{}
	removedideas             map[uuid.UUID]struct{}
	clearedideas             bool
	sources                  map[uuid.UUID]struct{}
	removedsources           map[uuid.UUID]struct{}
	clearedsources           bool
	nutrition                *int
	clearednutrition         bool
	ingredients              map[uuid.UUID]struct{}
	removedingredients       map[uuid.UUID]struct{}
	clearedingredients       bool
	done                     bool
	oldValue                 func(context.Context) (*Recipe, error)
	predicates               []predicate.Recipe
}

var _ ent.Mutation = (*RecipeMutation)(nil)

// recipeOption allows management of the mutation configuration using functional options.
type recipeOption func(*RecipeMutation)

// newRecipeMutation creates new mutation for the Recipe entity.
func newRecipeMutation(c config, op Op, opts ...recipeOption) *RecipeMutation {
	m := &RecipeMutation{
		config:        c,
		op:            op,
		typ:           TypeRecipe,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRecipeID sets the ID field of the mutation.
func withRecipeID(id uuid.UUID) recipeOption {
	return func(m *RecipeMutation) {
		var (
			err   error
			once  sync.Once
			value *Recipe
		)
		m.oldValue = func(ctx context.Context) (*Recipe, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Recipe.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRecipe sets the old Recipe of the mutation.
func withRecipe(node *Recipe) recipeOption {
	return func(m *RecipeMutation) {
		m.oldValue = func(context.Context) (*Recipe, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RecipeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RecipeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Recipe entities.
func (m *RecipeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RecipeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RecipeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Recipe.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *RecipeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *RecipeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Recipe entity.
// If the Recipe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecipeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *RecipeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *RecipeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *RecipeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Recipe entity.
// If the Recipe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecipeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *RecipeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetLocale sets the "locale" field.
func (m *RecipeMutation) SetLocale(r recipe.Locale) {
	m.locale = &r
}

// Locale returns the value of the "locale" field in the mutation.
func (m *RecipeMutation) Locale() (r recipe.Locale, exists bool) {
	v := m.locale
	if v == nil {
		return
	}
	return *v, true
}

// OldLocale returns the old "locale" field's value of the Recipe entity.
// If the Recipe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecipeMutation) OldLocale(ctx context.Context) (v recipe.Locale, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocale is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocale: %w", err)
	}
	return oldValue.Locale, nil
}

// ResetLocale resets all changes to the "locale" field.
func (m *RecipeMutation) ResetLocale() {
	m.locale = nil
}

// SetName sets the "name" field.
func (m *RecipeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RecipeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Recipe entity.
// If the Recipe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecipeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RecipeMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *RecipeMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *RecipeMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Recipe entity.
// If the Recipe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecipeMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *RecipeMutation) ResetSlug() {
	m.slug = nil
}

// SetDescription sets the "description" field.
func (m *RecipeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RecipeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Recipe entity.
// If the Recipe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecipeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *RecipeMutation) ResetDescription() {
	m.description = nil
}

// SetText sets the "text" field.
func (m *RecipeMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *RecipeMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the Recipe entity.
// If the Recipe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecipeMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ResetText resets all changes to the "text" field.
func (m *RecipeMutation) ResetText() {
	m.text = nil
}

// SetServings sets the "servings" field.
func (m *RecipeMutation) SetServings(i int) {
	m.servings = &i
	m.addservings = nil
}

// Servings returns the value of the "servings" field in the mutation.
func (m *RecipeMutation) Servings() (r int, exists bool) {
	v := m.servings
	if v == nil {
		return
	}
	return *v, true
}

// OldServings returns the old "servings" field's value of the Recipe entity.
// If the Recipe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecipeMutation) OldServings(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServings: %w", err)
	}
	return oldValue.Servings, nil
}

// AddServings adds i to the "servings" field.
func (m *RecipeMutation) AddServings(i int) {
	if m.addservings != nil {
		*m.addservings += i
	} else {
		m.addservings = &i
	}
}

// AddedServings returns the value that was added to the "servings" field in this mutation.
func (m *RecipeMutation) AddedServings() (r int, exists bool) {
	v := m.addservings
	if v == nil {
		return
	}
	return *v, true
}

// ClearServings clears the value of the "servings" field.
func (m *RecipeMutation) ClearServings() {
	m.servings = nil
	m.addservings = nil
	m.clearedFields[recipe.FieldServings] = struct{}{}
}

// ServingsCleared returns if the "servings" field was cleared in this mutation.
func (m *RecipeMutation) ServingsCleared() bool {
	_, ok := m.clearedFields[recipe.FieldServings]
	return ok
}

// ResetServings resets all changes to the "servings" field.
func (m *RecipeMutation) ResetServings() {
	m.servings = nil
	m.addservings = nil
	delete(m.clearedFields, recipe.FieldServings)
}

// SetTime sets the "time" field.
func (m *RecipeMutation) SetTime(t time.Duration) {
	m.time = &t
	m.addtime = nil
}

// Time returns the value of the "time" field in the mutation.
func (m *RecipeMutation) Time() (r time.Duration, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the Recipe entity.
// If the Recipe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecipeMutation) OldTime(ctx context.Context) (v *time.Duration, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// AddTime adds t to the "time" field.
func (m *RecipeMutation) AddTime(t time.Duration) {
	if m.addtime != nil {
		*m.addtime += t
	} else {
		m.addtime = &t
	}
}

// AddedTime returns the value that was added to the "time" field in this mutation.
func (m *RecipeMutation) AddedTime() (r time.Duration, exists bool) {
	v := m.addtime
	if v == nil {
		return
	}
	return *v, true
}

// ClearTime clears the value of the "time" field.
func (m *RecipeMutation) ClearTime() {
	m.time = nil
	m.addtime = nil
	m.clearedFields[recipe.FieldTime] = struct{}{}
}

// TimeCleared returns if the "time" field was cleared in this mutation.
func (m *RecipeMutation) TimeCleared() bool {
	_, ok := m.clearedFields[recipe.FieldTime]
	return ok
}

// ResetTime resets all changes to the "time" field.
func (m *RecipeMutation) ResetTime() {
	m.time = nil
	m.addtime = nil
	delete(m.clearedFields, recipe.FieldTime)
}

// AddRequiredProductIDs adds the "required_products" edge to the Product entity by ids.
func (m *RecipeMutation) AddRequiredProductIDs(ids ...uuid.UUID) {
	if m.required_products == nil {
		m.required_products = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.required_products[ids[i]] = struct{}{}
	}
}

// ClearRequiredProducts clears the "required_products" edge to the Product entity.
func (m *RecipeMutation) ClearRequiredProducts() {
	m.clearedrequired_products = true
}

// RequiredProductsCleared reports if the "required_products" edge to the Product entity was cleared.
func (m *RecipeMutation) RequiredProductsCleared() bool {
	return m.clearedrequired_products
}

// RemoveRequiredProductIDs removes the "required_products" edge to the Product entity by IDs.
func (m *RecipeMutation) RemoveRequiredProductIDs(ids ...uuid.UUID) {
	if m.removedrequired_products == nil {
		m.removedrequired_products = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.required_products, ids[i])
		m.removedrequired_products[ids[i]] = struct{}{}
	}
}

// RemovedRequiredProducts returns the removed IDs of the "required_products" edge to the Product entity.
func (m *RecipeMutation) RemovedRequiredProductsIDs() (ids []uuid.UUID) {
	for id := range m.removedrequired_products {
		ids = append(ids, id)
	}
	return
}

// RequiredProductsIDs returns the "required_products" edge IDs in the mutation.
func (m *RecipeMutation) RequiredProductsIDs() (ids []uuid.UUID) {
	for id := range m.required_products {
		ids = append(ids, id)
	}
	return
}

// ResetRequiredProducts resets all changes to the "required_products" edge.
func (m *RecipeMutation) ResetRequiredProducts() {
	m.required_products = nil
	m.clearedrequired_products = false
	m.removedrequired_products = nil
}

// AddInstructionIDs adds the "instructions" edge to the Instruction entity by ids.
func (m *RecipeMutation) AddInstructionIDs(ids ...uuid.UUID) {
	if m.instructions == nil {
		m.instructions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.instructions[ids[i]] = struct{}{}
	}
}

// ClearInstructions clears the "instructions" edge to the Instruction entity.
func (m *RecipeMutation) ClearInstructions() {
	m.clearedinstructions = true
}

// InstructionsCleared reports if the "instructions" edge to the Instruction entity was cleared.
func (m *RecipeMutation) InstructionsCleared() bool {
	return m.clearedinstructions
}

// RemoveInstructionIDs removes the "instructions" edge to the Instruction entity by IDs.
func (m *RecipeMutation) RemoveInstructionIDs(ids ...uuid.UUID) {
	if m.removedinstructions == nil {
		m.removedinstructions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.instructions, ids[i])
		m.removedinstructions[ids[i]] = struct{}{}
	}
}

// RemovedInstructions returns the removed IDs of the "instructions" edge to the Instruction entity.
func (m *RecipeMutation) RemovedInstructionsIDs() (ids []uuid.UUID) {
	for id := range m.removedinstructions {
		ids = append(ids, id)
	}
	return
}

// InstructionsIDs returns the "instructions" edge IDs in the mutation.
func (m *RecipeMutation) InstructionsIDs() (ids []uuid.UUID) {
	for id := range m.instructions {
		ids = append(ids, id)
	}
	return
}

// ResetInstructions resets all changes to the "instructions" edge.
func (m *RecipeMutation) ResetInstructions() {
	m.instructions = nil
	m.clearedinstructions = false
	m.removedinstructions = nil
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *RecipeMutation) AddTagIDs(ids ...uuid.UUID) {
	if m.tags == nil {
		m.tags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *RecipeMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *RecipeMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *RecipeMutation) RemoveTagIDs(ids ...uuid.UUID) {
	if m.removedtags == nil {
		m.removedtags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *RecipeMutation) RemovedTagsIDs() (ids []uuid.UUID) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *RecipeMutation) TagsIDs() (ids []uuid.UUID) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *RecipeMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// AddEquipmentIDs adds the "equipment" edge to the Equipment entity by ids.
func (m *RecipeMutation) AddEquipmentIDs(ids ...uuid.UUID) {
	if m.equipment == nil {
		m.equipment = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.equipment[ids[i]] = struct{}{}
	}
}

// ClearEquipment clears the "equipment" edge to the Equipment entity.
func (m *RecipeMutation) ClearEquipment() {
	m.clearedequipment = true
}

// EquipmentCleared reports if the "equipment" edge to the Equipment entity was cleared.
func (m *RecipeMutation) EquipmentCleared() bool {
	return m.clearedequipment
}

// RemoveEquipmentIDs removes the "equipment" edge to the Equipment entity by IDs.
func (m *RecipeMutation) RemoveEquipmentIDs(ids ...uuid.UUID) {
	if m.removedequipment == nil {
		m.removedequipment = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.equipment, ids[i])
		m.removedequipment[ids[i]] = struct{}{}
	}
}

// RemovedEquipment returns the removed IDs of the "equipment" edge to the Equipment entity.
func (m *RecipeMutation) RemovedEquipmentIDs() (ids []uuid.UUID) {
	for id := range m.removedequipment {
		ids = append(ids, id)
	}
	return
}

// EquipmentIDs returns the "equipment" edge IDs in the mutation.
func (m *RecipeMutation) EquipmentIDs() (ids []uuid.UUID) {
	for id := range m.equipment {
		ids = append(ids, id)
	}
	return
}

// ResetEquipment resets all changes to the "equipment" edge.
func (m *RecipeMutation) ResetEquipment() {
	m.equipment = nil
	m.clearedequipment = false
	m.removedequipment = nil
}

// AddIdeaIDs adds the "ideas" edge to the Idea entity by ids.
func (m *RecipeMutation) AddIdeaIDs(ids ...uuid.UUID) {
	if m.ideas == nil {
		m.ideas = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.ideas[ids[i]] = struct{}{}
	}
}

// ClearIdeas clears the "ideas" edge to the Idea entity.
func (m *RecipeMutation) ClearIdeas() {
	m.clearedideas = true
}

// IdeasCleared reports if the "ideas" edge to the Idea entity was cleared.
func (m *RecipeMutation) IdeasCleared() bool {
	return m.clearedideas
}

// RemoveIdeaIDs removes the "ideas" edge to the Idea entity by IDs.
func (m *RecipeMutation) RemoveIdeaIDs(ids ...uuid.UUID) {
	if m.removedideas == nil {
		m.removedideas = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.ideas, ids[i])
		m.removedideas[ids[i]] = struct{}{}
	}
}

// RemovedIdeas returns the removed IDs of the "ideas" edge to the Idea entity.
func (m *RecipeMutation) RemovedIdeasIDs() (ids []uuid.UUID) {
	for id := range m.removedideas {
		ids = append(ids, id)
	}
	return
}

// IdeasIDs returns the "ideas" edge IDs in the mutation.
func (m *RecipeMutation) IdeasIDs() (ids []uuid.UUID) {
	for id := range m.ideas {
		ids = append(ids, id)
	}
	return
}

// ResetIdeas resets all changes to the "ideas" edge.
func (m *RecipeMutation) ResetIdeas() {
	m.ideas = nil
	m.clearedideas = false
	m.removedideas = nil
}

// AddSourceIDs adds the "sources" edge to the Source entity by ids.
func (m *RecipeMutation) AddSourceIDs(ids ...uuid.UUID) {
	if m.sources == nil {
		m.sources = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.sources[ids[i]] = struct{}{}
	}
}

// ClearSources clears the "sources" edge to the Source entity.
func (m *RecipeMutation) ClearSources() {
	m.clearedsources = true
}

// SourcesCleared reports if the "sources" edge to the Source entity was cleared.
func (m *RecipeMutation) SourcesCleared() bool {
	return m.clearedsources
}

// RemoveSourceIDs removes the "sources" edge to the Source entity by IDs.
func (m *RecipeMutation) RemoveSourceIDs(ids ...uuid.UUID) {
	if m.removedsources == nil {
		m.removedsources = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.sources, ids[i])
		m.removedsources[ids[i]] = struct{}{}
	}
}

// RemovedSources returns the removed IDs of the "sources" edge to the Source entity.
func (m *RecipeMutation) RemovedSourcesIDs() (ids []uuid.UUID) {
	for id := range m.removedsources {
		ids = append(ids, id)
	}
	return
}

// SourcesIDs returns the "sources" edge IDs in the mutation.
func (m *RecipeMutation) SourcesIDs() (ids []uuid.UUID) {
	for id := range m.sources {
		ids = append(ids, id)
	}
	return
}

// ResetSources resets all changes to the "sources" edge.
func (m *RecipeMutation) ResetSources() {
	m.sources = nil
	m.clearedsources = false
	m.removedsources = nil
}

// SetNutritionID sets the "nutrition" edge to the Nutrition entity by id.
func (m *RecipeMutation) SetNutritionID(id int) {
	m.nutrition = &id
}

// ClearNutrition clears the "nutrition" edge to the Nutrition entity.
func (m *RecipeMutation) ClearNutrition() {
	m.clearednutrition = true
}

// NutritionCleared reports if the "nutrition" edge to the Nutrition entity was cleared.
func (m *RecipeMutation) NutritionCleared() bool {
	return m.clearednutrition
}

// NutritionID returns the "nutrition" edge ID in the mutation.
func (m *RecipeMutation) NutritionID() (id int, exists bool) {
	if m.nutrition != nil {
		return *m.nutrition, true
	}
	return
}

// NutritionIDs returns the "nutrition" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NutritionID instead. It exists only for internal usage by the builders.
func (m *RecipeMutation) NutritionIDs() (ids []int) {
	if id := m.nutrition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNutrition resets all changes to the "nutrition" edge.
func (m *RecipeMutation) ResetNutrition() {
	m.nutrition = nil
	m.clearednutrition = false
}

// AddIngredientIDs adds the "ingredients" edge to the Ingredient entity by ids.
func (m *RecipeMutation) AddIngredientIDs(ids ...uuid.UUID) {
	if m.ingredients == nil {
		m.ingredients = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.ingredients[ids[i]] = struct{}{}
	}
}

// ClearIngredients clears the "ingredients" edge to the Ingredient entity.
func (m *RecipeMutation) ClearIngredients() {
	m.clearedingredients = true
}

// IngredientsCleared reports if the "ingredients" edge to the Ingredient entity was cleared.
func (m *RecipeMutation) IngredientsCleared() bool {
	return m.clearedingredients
}

// RemoveIngredientIDs removes the "ingredients" edge to the Ingredient entity by IDs.
func (m *RecipeMutation) RemoveIngredientIDs(ids ...uuid.UUID) {
	if m.removedingredients == nil {
		m.removedingredients = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.ingredients, ids[i])
		m.removedingredients[ids[i]] = struct{}{}
	}
}

// RemovedIngredients returns the removed IDs of the "ingredients" edge to the Ingredient entity.
func (m *RecipeMutation) RemovedIngredientsIDs() (ids []uuid.UUID) {
	for id := range m.removedingredients {
		ids = append(ids, id)
	}
	return
}

// IngredientsIDs returns the "ingredients" edge IDs in the mutation.
func (m *RecipeMutation) IngredientsIDs() (ids []uuid.UUID) {
	for id := range m.ingredients {
		ids = append(ids, id)
	}
	return
}

// ResetIngredients resets all changes to the "ingredients" edge.
func (m *RecipeMutation) ResetIngredients() {
	m.ingredients = nil
	m.clearedingredients = false
	m.removedingredients = nil
}

// Where appends a list predicates to the RecipeMutation builder.
func (m *RecipeMutation) Where(ps ...predicate.Recipe) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RecipeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RecipeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Recipe, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RecipeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RecipeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Recipe).
func (m *RecipeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RecipeMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, recipe.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, recipe.FieldUpdateTime)
	}
	if m.locale != nil {
		fields = append(fields, recipe.FieldLocale)
	}
	if m.name != nil {
		fields = append(fields, recipe.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, recipe.FieldSlug)
	}
	if m.description != nil {
		fields = append(fields, recipe.FieldDescription)
	}
	if m.text != nil {
		fields = append(fields, recipe.FieldText)
	}
	if m.servings != nil {
		fields = append(fields, recipe.FieldServings)
	}
	if m.time != nil {
		fields = append(fields, recipe.FieldTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RecipeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case recipe.FieldCreateTime:
		return m.CreateTime()
	case recipe.FieldUpdateTime:
		return m.UpdateTime()
	case recipe.FieldLocale:
		return m.Locale()
	case recipe.FieldName:
		return m.Name()
	case recipe.FieldSlug:
		return m.Slug()
	case recipe.FieldDescription:
		return m.Description()
	case recipe.FieldText:
		return m.Text()
	case recipe.FieldServings:
		return m.Servings()
	case recipe.FieldTime:
		return m.Time()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RecipeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case recipe.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case recipe.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case recipe.FieldLocale:
		return m.OldLocale(ctx)
	case recipe.FieldName:
		return m.OldName(ctx)
	case recipe.FieldSlug:
		return m.OldSlug(ctx)
	case recipe.FieldDescription:
		return m.OldDescription(ctx)
	case recipe.FieldText:
		return m.OldText(ctx)
	case recipe.FieldServings:
		return m.OldServings(ctx)
	case recipe.FieldTime:
		return m.OldTime(ctx)
	}
	return nil, fmt.Errorf("unknown Recipe field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecipeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case recipe.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case recipe.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case recipe.FieldLocale:
		v, ok := value.(recipe.Locale)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocale(v)
		return nil
	case recipe.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case recipe.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case recipe.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case recipe.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	case recipe.FieldServings:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServings(v)
		return nil
	case recipe.FieldTime:
		v, ok := value.(time.Duration)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	}
	return fmt.Errorf("unknown Recipe field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RecipeMutation) AddedFields() []string {
	var fields []string
	if m.addservings != nil {
		fields = append(fields, recipe.FieldServings)
	}
	if m.addtime != nil {
		fields = append(fields, recipe.FieldTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RecipeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case recipe.FieldServings:
		return m.AddedServings()
	case recipe.FieldTime:
		return m.AddedTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecipeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case recipe.FieldServings:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddServings(v)
		return nil
	case recipe.FieldTime:
		v, ok := value.(time.Duration)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTime(v)
		return nil
	}
	return fmt.Errorf("unknown Recipe numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RecipeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(recipe.FieldServings) {
		fields = append(fields, recipe.FieldServings)
	}
	if m.FieldCleared(recipe.FieldTime) {
		fields = append(fields, recipe.FieldTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RecipeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RecipeMutation) ClearField(name string) error {
	switch name {
	case recipe.FieldServings:
		m.ClearServings()
		return nil
	case recipe.FieldTime:
		m.ClearTime()
		return nil
	}
	return fmt.Errorf("unknown Recipe nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RecipeMutation) ResetField(name string) error {
	switch name {
	case recipe.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case recipe.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case recipe.FieldLocale:
		m.ResetLocale()
		return nil
	case recipe.FieldName:
		m.ResetName()
		return nil
	case recipe.FieldSlug:
		m.ResetSlug()
		return nil
	case recipe.FieldDescription:
		m.ResetDescription()
		return nil
	case recipe.FieldText:
		m.ResetText()
		return nil
	case recipe.FieldServings:
		m.ResetServings()
		return nil
	case recipe.FieldTime:
		m.ResetTime()
		return nil
	}
	return fmt.Errorf("unknown Recipe field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RecipeMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.required_products != nil {
		edges = append(edges, recipe.EdgeRequiredProducts)
	}
	if m.instructions != nil {
		edges = append(edges, recipe.EdgeInstructions)
	}
	if m.tags != nil {
		edges = append(edges, recipe.EdgeTags)
	}
	if m.equipment != nil {
		edges = append(edges, recipe.EdgeEquipment)
	}
	if m.ideas != nil {
		edges = append(edges, recipe.EdgeIdeas)
	}
	if m.sources != nil {
		edges = append(edges, recipe.EdgeSources)
	}
	if m.nutrition != nil {
		edges = append(edges, recipe.EdgeNutrition)
	}
	if m.ingredients != nil {
		edges = append(edges, recipe.EdgeIngredients)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RecipeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case recipe.EdgeRequiredProducts:
		ids := make([]ent.Value, 0, len(m.required_products))
		for id := range m.required_products {
			ids = append(ids, id)
		}
		return ids
	case recipe.EdgeInstructions:
		ids := make([]ent.Value, 0, len(m.instructions))
		for id := range m.instructions {
			ids = append(ids, id)
		}
		return ids
	case recipe.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case recipe.EdgeEquipment:
		ids := make([]ent.Value, 0, len(m.equipment))
		for id := range m.equipment {
			ids = append(ids, id)
		}
		return ids
	case recipe.EdgeIdeas:
		ids := make([]ent.Value, 0, len(m.ideas))
		for id := range m.ideas {
			ids = append(ids, id)
		}
		return ids
	case recipe.EdgeSources:
		ids := make([]ent.Value, 0, len(m.sources))
		for id := range m.sources {
			ids = append(ids, id)
		}
		return ids
	case recipe.EdgeNutrition:
		if id := m.nutrition; id != nil {
			return []ent.Value{*id}
		}
	case recipe.EdgeIngredients:
		ids := make([]ent.Value, 0, len(m.ingredients))
		for id := range m.ingredients {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RecipeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedrequired_products != nil {
		edges = append(edges, recipe.EdgeRequiredProducts)
	}
	if m.removedinstructions != nil {
		edges = append(edges, recipe.EdgeInstructions)
	}
	if m.removedtags != nil {
		edges = append(edges, recipe.EdgeTags)
	}
	if m.removedequipment != nil {
		edges = append(edges, recipe.EdgeEquipment)
	}
	if m.removedideas != nil {
		edges = append(edges, recipe.EdgeIdeas)
	}
	if m.removedsources != nil {
		edges = append(edges, recipe.EdgeSources)
	}
	if m.removedingredients != nil {
		edges = append(edges, recipe.EdgeIngredients)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RecipeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case recipe.EdgeRequiredProducts:
		ids := make([]ent.Value, 0, len(m.removedrequired_products))
		for id := range m.removedrequired_products {
			ids = append(ids, id)
		}
		return ids
	case recipe.EdgeInstructions:
		ids := make([]ent.Value, 0, len(m.removedinstructions))
		for id := range m.removedinstructions {
			ids = append(ids, id)
		}
		return ids
	case recipe.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case recipe.EdgeEquipment:
		ids := make([]ent.Value, 0, len(m.removedequipment))
		for id := range m.removedequipment {
			ids = append(ids, id)
		}
		return ids
	case recipe.EdgeIdeas:
		ids := make([]ent.Value, 0, len(m.removedideas))
		for id := range m.removedideas {
			ids = append(ids, id)
		}
		return ids
	case recipe.EdgeSources:
		ids := make([]ent.Value, 0, len(m.removedsources))
		for id := range m.removedsources {
			ids = append(ids, id)
		}
		return ids
	case recipe.EdgeIngredients:
		ids := make([]ent.Value, 0, len(m.removedingredients))
		for id := range m.removedingredients {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RecipeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedrequired_products {
		edges = append(edges, recipe.EdgeRequiredProducts)
	}
	if m.clearedinstructions {
		edges = append(edges, recipe.EdgeInstructions)
	}
	if m.clearedtags {
		edges = append(edges, recipe.EdgeTags)
	}
	if m.clearedequipment {
		edges = append(edges, recipe.EdgeEquipment)
	}
	if m.clearedideas {
		edges = append(edges, recipe.EdgeIdeas)
	}
	if m.clearedsources {
		edges = append(edges, recipe.EdgeSources)
	}
	if m.clearednutrition {
		edges = append(edges, recipe.EdgeNutrition)
	}
	if m.clearedingredients {
		edges = append(edges, recipe.EdgeIngredients)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RecipeMutation) EdgeCleared(name string) bool {
	switch name {
	case recipe.EdgeRequiredProducts:
		return m.clearedrequired_products
	case recipe.EdgeInstructions:
		return m.clearedinstructions
	case recipe.EdgeTags:
		return m.clearedtags
	case recipe.EdgeEquipment:
		return m.clearedequipment
	case recipe.EdgeIdeas:
		return m.clearedideas
	case recipe.EdgeSources:
		return m.clearedsources
	case recipe.EdgeNutrition:
		return m.clearednutrition
	case recipe.EdgeIngredients:
		return m.clearedingredients
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RecipeMutation) ClearEdge(name string) error {
	switch name {
	case recipe.EdgeNutrition:
		m.ClearNutrition()
		return nil
	}
	return fmt.Errorf("unknown Recipe unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RecipeMutation) ResetEdge(name string) error {
	switch name {
	case recipe.EdgeRequiredProducts:
		m.ResetRequiredProducts()
		return nil
	case recipe.EdgeInstructions:
		m.ResetInstructions()
		return nil
	case recipe.EdgeTags:
		m.ResetTags()
		return nil
	case recipe.EdgeEquipment:
		m.ResetEquipment()
		return nil
	case recipe.EdgeIdeas:
		m.ResetIdeas()
		return nil
	case recipe.EdgeSources:
		m.ResetSources()
		return nil
	case recipe.EdgeNutrition:
		m.ResetNutrition()
		return nil
	case recipe.EdgeIngredients:
		m.ResetIngredients()
		return nil
	}
	return fmt.Errorf("unknown Recipe edge %s", name)
}

// SourceMutation represents an operation that mutates the Source nodes in the graph.
type SourceMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	name          *string
	description   *string
	url           *string
	clearedFields map[string]struct{}
	recipe        *uuid.UUID
	clearedrecipe bool
	done          bool
	oldValue      func(context.Context) (*Source, error)
	predicates    []predicate.Source
}

var _ ent.Mutation = (*SourceMutation)(nil)

// sourceOption allows management of the mutation configuration using functional options.
type sourceOption func(*SourceMutation)

// newSourceMutation creates new mutation for the Source entity.
func newSourceMutation(c config, op Op, opts ...sourceOption) *SourceMutation {
	m := &SourceMutation{
		config:        c,
		op:            op,
		typ:           TypeSource,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSourceID sets the ID field of the mutation.
func withSourceID(id uuid.UUID) sourceOption {
	return func(m *SourceMutation) {
		var (
			err   error
			once  sync.Once
			value *Source
		)
		m.oldValue = func(ctx context.Context) (*Source, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Source.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSource sets the old Source of the mutation.
func withSource(node *Source) sourceOption {
	return func(m *SourceMutation) {
		m.oldValue = func(context.Context) (*Source, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SourceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SourceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Source entities.
func (m *SourceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SourceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SourceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Source.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SourceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SourceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Source entity.
// If the Source object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *SourceMutation) ClearName() {
	m.name = nil
	m.clearedFields[source.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *SourceMutation) NameCleared() bool {
	_, ok := m.clearedFields[source.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *SourceMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, source.FieldName)
}

// SetDescription sets the "description" field.
func (m *SourceMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SourceMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Source entity.
// If the Source object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SourceMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[source.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SourceMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[source.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SourceMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, source.FieldDescription)
}

// SetURL sets the "url" field.
func (m *SourceMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *SourceMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Source entity.
// If the Source object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *SourceMutation) ClearURL() {
	m.url = nil
	m.clearedFields[source.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *SourceMutation) URLCleared() bool {
	_, ok := m.clearedFields[source.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *SourceMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, source.FieldURL)
}

// SetRecipeID sets the "recipe" edge to the Recipe entity by id.
func (m *SourceMutation) SetRecipeID(id uuid.UUID) {
	m.recipe = &id
}

// ClearRecipe clears the "recipe" edge to the Recipe entity.
func (m *SourceMutation) ClearRecipe() {
	m.clearedrecipe = true
}

// RecipeCleared reports if the "recipe" edge to the Recipe entity was cleared.
func (m *SourceMutation) RecipeCleared() bool {
	return m.clearedrecipe
}

// RecipeID returns the "recipe" edge ID in the mutation.
func (m *SourceMutation) RecipeID() (id uuid.UUID, exists bool) {
	if m.recipe != nil {
		return *m.recipe, true
	}
	return
}

// RecipeIDs returns the "recipe" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RecipeID instead. It exists only for internal usage by the builders.
func (m *SourceMutation) RecipeIDs() (ids []uuid.UUID) {
	if id := m.recipe; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRecipe resets all changes to the "recipe" edge.
func (m *SourceMutation) ResetRecipe() {
	m.recipe = nil
	m.clearedrecipe = false
}

// Where appends a list predicates to the SourceMutation builder.
func (m *SourceMutation) Where(ps ...predicate.Source) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SourceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SourceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Source, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SourceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SourceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Source).
func (m *SourceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SourceMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, source.FieldName)
	}
	if m.description != nil {
		fields = append(fields, source.FieldDescription)
	}
	if m.url != nil {
		fields = append(fields, source.FieldURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SourceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case source.FieldName:
		return m.Name()
	case source.FieldDescription:
		return m.Description()
	case source.FieldURL:
		return m.URL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SourceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case source.FieldName:
		return m.OldName(ctx)
	case source.FieldDescription:
		return m.OldDescription(ctx)
	case source.FieldURL:
		return m.OldURL(ctx)
	}
	return nil, fmt.Errorf("unknown Source field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case source.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case source.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case source.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	}
	return fmt.Errorf("unknown Source field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SourceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SourceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Source numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SourceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(source.FieldName) {
		fields = append(fields, source.FieldName)
	}
	if m.FieldCleared(source.FieldDescription) {
		fields = append(fields, source.FieldDescription)
	}
	if m.FieldCleared(source.FieldURL) {
		fields = append(fields, source.FieldURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SourceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SourceMutation) ClearField(name string) error {
	switch name {
	case source.FieldName:
		m.ClearName()
		return nil
	case source.FieldDescription:
		m.ClearDescription()
		return nil
	case source.FieldURL:
		m.ClearURL()
		return nil
	}
	return fmt.Errorf("unknown Source nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SourceMutation) ResetField(name string) error {
	switch name {
	case source.FieldName:
		m.ResetName()
		return nil
	case source.FieldDescription:
		m.ResetDescription()
		return nil
	case source.FieldURL:
		m.ResetURL()
		return nil
	}
	return fmt.Errorf("unknown Source field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SourceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.recipe != nil {
		edges = append(edges, source.EdgeRecipe)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SourceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case source.EdgeRecipe:
		if id := m.recipe; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SourceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SourceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SourceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrecipe {
		edges = append(edges, source.EdgeRecipe)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SourceMutation) EdgeCleared(name string) bool {
	switch name {
	case source.EdgeRecipe:
		return m.clearedrecipe
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SourceMutation) ClearEdge(name string) error {
	switch name {
	case source.EdgeRecipe:
		m.ClearRecipe()
		return nil
	}
	return fmt.Errorf("unknown Source unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SourceMutation) ResetEdge(name string) error {
	switch name {
	case source.EdgeRecipe:
		m.ResetRecipe()
		return nil
	}
	return fmt.Errorf("unknown Source edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	name           *string
	group          *string
	clearedFields  map[string]struct{}
	recipes        map[uuid.UUID]struct{}
	removedrecipes map[uuid.UUID]struct{}
	clearedrecipes bool
	done           bool
	oldValue       func(context.Context) (*Tag, error)
	predicates     []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id uuid.UUID) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tag entities.
func (m *TagMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TagMutation) ResetName() {
	m.name = nil
}

// SetGroup sets the "group" field.
func (m *TagMutation) SetGroup(s string) {
	m.group = &s
}

// Group returns the value of the "group" field in the mutation.
func (m *TagMutation) Group() (r string, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroup returns the old "group" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldGroup(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroup: %w", err)
	}
	return oldValue.Group, nil
}

// ResetGroup resets all changes to the "group" field.
func (m *TagMutation) ResetGroup() {
	m.group = nil
}

// AddRecipeIDs adds the "recipes" edge to the Recipe entity by ids.
func (m *TagMutation) AddRecipeIDs(ids ...uuid.UUID) {
	if m.recipes == nil {
		m.recipes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.recipes[ids[i]] = struct{}{}
	}
}

// ClearRecipes clears the "recipes" edge to the Recipe entity.
func (m *TagMutation) ClearRecipes() {
	m.clearedrecipes = true
}

// RecipesCleared reports if the "recipes" edge to the Recipe entity was cleared.
func (m *TagMutation) RecipesCleared() bool {
	return m.clearedrecipes
}

// RemoveRecipeIDs removes the "recipes" edge to the Recipe entity by IDs.
func (m *TagMutation) RemoveRecipeIDs(ids ...uuid.UUID) {
	if m.removedrecipes == nil {
		m.removedrecipes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.recipes, ids[i])
		m.removedrecipes[ids[i]] = struct{}{}
	}
}

// RemovedRecipes returns the removed IDs of the "recipes" edge to the Recipe entity.
func (m *TagMutation) RemovedRecipesIDs() (ids []uuid.UUID) {
	for id := range m.removedrecipes {
		ids = append(ids, id)
	}
	return
}

// RecipesIDs returns the "recipes" edge IDs in the mutation.
func (m *TagMutation) RecipesIDs() (ids []uuid.UUID) {
	for id := range m.recipes {
		ids = append(ids, id)
	}
	return
}

// ResetRecipes resets all changes to the "recipes" edge.
func (m *TagMutation) ResetRecipes() {
	m.recipes = nil
	m.clearedrecipes = false
	m.removedrecipes = nil
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, tag.FieldName)
	}
	if m.group != nil {
		fields = append(fields, tag.FieldGroup)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldName:
		return m.Name()
	case tag.FieldGroup:
		return m.Group()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldName:
		return m.OldName(ctx)
	case tag.FieldGroup:
		return m.OldGroup(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tag.FieldGroup:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroup(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldName:
		m.ResetName()
		return nil
	case tag.FieldGroup:
		m.ResetGroup()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.recipes != nil {
		edges = append(edges, tag.EdgeRecipes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeRecipes:
		ids := make([]ent.Value, 0, len(m.recipes))
		for id := range m.recipes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedrecipes != nil {
		edges = append(edges, tag.EdgeRecipes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeRecipes:
		ids := make([]ent.Value, 0, len(m.removedrecipes))
		for id := range m.removedrecipes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrecipes {
		edges = append(edges, tag.EdgeRecipes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	case tag.EdgeRecipes:
		return m.clearedrecipes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgeRecipes:
		m.ResetRecipes()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}
